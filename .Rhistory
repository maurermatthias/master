segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1)
segments(x.new[no.ob],1,1,1,col="red")
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
points(x.new,y.new,col="red",pch=24)
}
print.edf(1:9/10)
#print gained EDF for p-values
print.edf<-function(x){
x.new=unique(sort(x))
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1)
segments(x.new[no.ob],1,1,1,col="red")
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10)
print.edf<-function(x){
x.new=unique(sort(x))
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else{
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10)
print.edf(1:9/10)
print.edf(1:10/10)
print.edf(1:100/100)
print.edf<-function(x){
x.new=unique(sort(x))
points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10)
print.edf<-function(x){
x.new=unique(sort(x))
points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10)
print.edf(1:100/100)
print.edf(1:9/10)
print.edf(1:9/10,TRUE)
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10)
print.edf(1:9/10,TRUE)
#print gained EDF for p-values
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
abline(h=0)
abline(v=0)
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
abline(h=-0.00001)
abline(v=-0.00001)
}
print.edf(1:9/10,TRUE)
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
abline(h=-0.01)
abline(v=-0.01)
}
print.edf(1:9/10,TRUE)
#print gained EDF for p-values
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
abline(h=-0.01)
abline(v=-0.01)
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
#print gained EDF for p-values
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
abline(h=0)
abline(v=0)
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
abline(h=0,col="grey")
#print gained EDF for p-values
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
abline(h=0,col="grey")
abline(v=0,col="grey")
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
print.edf<-function(x, points=FALSE){
x.new=unique(sort(x))
#points=FALSE
no.ob=length(x.new)
y.new=c()
for(j in 1:no.ob){
y.tmp=sum(x.new<=x.new[j])/no.ob
y.new=c(y.new,y.tmp)
}
plot(1, type="n", xlab="", ylab="", xlim=c(0, 1), ylim=c(0, 1))
#abline(h=0,col="grey")
#abline(v=0,col="grey")
if(x.new[1]>0)
segments(0,0,x.new[1],0,col="red")
if(x.new[no.ob]<1){
segments(x.new[no.ob],1,1,1,col="red")
}else if(points){
points(1,1,col="red",pch=20)
}
for(j in 1:(no.ob-1)){
segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col="red")
}
if(points)
points(x.new,y.new,col="red",pch=20)
}
print.edf(1:9/10,TRUE)
pr.sim<-function(input, ratio, times){
if(is.null(input[["quantiles"]]))
stop("Quantiles are needed for this approach!")
input[["sim"]]=TRUE
p.val=c()
start.time = proc.time()[["elapsed"]]
display.steps=0.1
bool.m=create.rand.boolmatrix(input, ratio, times)
status.update("start calculation");
old.val=-1;
for(c in 1:times){
if(TRUE || (c/times)%%0.1==0){
val=round(100*(c/times))
if(old.val != val){
old.val=val;
msg = paste("Calculated ",as.character(val),"% in ",as.character(round(proc.time()[["elapsed"]]-start.time)),"[s].",sep="");
status.update(msg);
}
}
bool=bool.m[,c]
try({
p.val.tmp = sim(bool,input);
p.val=c(p.val,p.val.tmp)
}, silent=TRUE)
}
par(mfrow=c(2,1))
print.edf(p.avl)
hist(p.val)
return(p.val)
}
v=pr.sim(gev, 0.5, 500)
pr.sim<-function(input, ratio, times){
if(is.null(input[["quantiles"]]))
stop("Quantiles are needed for this approach!")
input[["sim"]]=TRUE
p.val=c()
start.time = proc.time()[["elapsed"]]
display.steps=0.1
bool.m=create.rand.boolmatrix(input, ratio, times)
status.update("start calculation");
old.val=-1;
for(c in 1:times){
if(TRUE || (c/times)%%0.1==0){
val=round(100*(c/times))
if(old.val != val){
old.val=val;
msg = paste("Calculated ",as.character(val),"% in ",as.character(round(proc.time()[["elapsed"]]-start.time)),"[s].",sep="");
status.update(msg);
}
}
bool=bool.m[,c]
try({
p.val.tmp = sim(bool,input);
p.val=c(p.val,p.val.tmp)
}, silent=TRUE)
}
par(mfrow=c(2,1))
print.edf(p.val)
hist(p.val)
return(p.val)
}
v=pr.sim(gev, 0.5, 500)
v=pr.sim(gev, 0.5, 500)
v=pr.sim(gev, 0.5, 500)
shen1
source('ParameterRegression.R')
gev=list();
gev[["distr"]]="gev"
gev[["error.type"]]="rel"
gev[["xval"]]=shen1[,1]
gev[["yval"]]=shen1[,2]
gev[["validity.fun"]]="val.gev"
gev[["struct.fun"]]=c("gev1","gev2","gev3")
gev[["struct.start.parameter"]]=c(-0.31,49.67,20809,18.8,69.41)
gev[["quantiles"]]=1:10/20
#validity function
val.gev<-function(stress,parameter){
k=parameter[1];
a=parameter[2];
b=parameter[3];
c1=parameter[4];
c2=parameter[5];
if(b<=max(stress) || a>=min(stress) || c1<=0 || c2<=0 || k==0){
return(FALSE);
}else{
return(TRUE);
}
}
#xi gev
gev1<-function(stress,parameter){
k=parameter[1];
return(k);
}
#sigma^2 gev
gev2<-function(stress,parameter){
a=parameter[2];
b=parameter[3];
c1=parameter[4];
return(((b-a)/(stress-a)-1)*c1)
}
#mu gev
gev3<-function(stress,parameter){
a=parameter[2];
b=parameter[3];
c2=parameter[5];
return(((b-a)/(stress-a)-1)*c2)
}
gev.result=pr(gev)
pr.parplot(gev.result)
gev[["quantiles"]]=1:9/10
v=pr.sim(gev, 0.5, 500)
hist(rnorm(50))
hist(rnorm(50),main="w")
par(mfrow=c(2,1))
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 500)
help(suppressWarnings)
length(v)
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
length(v)
20/17
17/20
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
warnings()
help(muffleWarning)
??muffleWarning
suppressWarnings2 <-
function(expr, regex=character())
{
withCallingHandlers(expr, warning=function(w) {
if (length(regex) == 1 && length(grep(regex, conditionMessage(w)))) {
invokeRestart("muffleWarning")
}
})
}
f <- function() {
warning("oops")
2
}
f()
suppressWarnings(f())
suppressWarnings2(f())
suppressWarnings2(f(),"oops")
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
warnings()
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
warnings()
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
warnings()
sqrt(-1)
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 20)
w=warnings()[1]
w
names(w)
w[[1]]
source('ParameterRegression.R')
v=pr.sim(gev, 0.5, 10)
v=pr.sim(gev, 0.5, 10)
v=pr.sim(gev, 0.5, 10)
