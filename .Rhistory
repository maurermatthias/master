mu=c(mu,mu.tmp)
}
xi = 0.1
return(c(xi,sigma,mu))
}
x=data[,1]
y=data[,2]
theta <- get.start.val(data)
#####negativeloglikelihod function vor gev-input, when having same xi
#tmp contains x and y values
negloglik <- function(theta, tmp) {
x=tmp[,1]
stress=unique(x)
y=tmp[,2]
xi=theta[1]
sigma.v=theta[2:(length(stress)+1)]
mu.v=theta[(length(stress)+2):(2*length(stress)+1)]
out=0
for(j in 1: length(stress)){
mu=mu.v[j]
sigma=sigma.v[j]
y.part=part(y,x==stress[j])
v <- 1 + (xi * (y.part - mu))/sigma
#print(v)
#print(sigma)
if ((sigma < 0) || (min(v) < 0))
out = out + 1e+06
else {
term1 <- length(y.part) * logb(sigma)
term2 <- sum((1 + 1/xi) * logb(v))
term3 <- sum(v^(-1/xi))
out = out + term1 + term2 + term3
}
}
out
}
if (is.na(control)) {
fit = optim(theta, negloglik, tmp = data)
} else {
fit = optim(theta, negloglik,  control , tmp = data)
}
if (fit$convergence)
warning("optimization may not have succeeded")
par.ests.all <- fit$par
par.ests = list(xi=par.ests.all[1], sigma=par.ests.all[1:length(unique(x))+1], mu = par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
standardize<-function(x,y,xi,sigma,mu){
y.new=c()
stress=unique(x)
for(j in 1:length(x)){
pos=which(x[j]==stress)
y.new=c(y.new,(y[j]-mu[pos])/sigma[pos])
}
return(y.new)
}
y.new=standardize(x,y,par.ests.all[1],par.ests.all[1:length(unique(x))+1],par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
out <- list(x=x, y=y, y.std=y.new,
par.ests = par.ests, counts=fit$counts,
converged = fit$convergence, nllh.final = fit$value)
#names(out$par.ests) <- c("xi", "sigma", "mu")
#names(out$par.ses) <- c("xi", "sigma", "mu")
#class(out) <- "gev2"
out
}
z=gev.xi.same(shen1)
z$counts
control = list(maxit=1000)
z=gev.xi.same(shen1, control)
z$counts
gev.xi.same<-function (data, control=NA)
{
print(control)
######calculate start value for optim
get.start.val<-function(data){
x=data[,1]
stress=unique(x)
y=data[,2]
sigma=c()
mu=c()
for(j in 1:length(stress)){
y.part=part(y,x==stress[j])
sigma.tmp=sqrt(6 * var(y.part))/pi
mu.tmp <- mean(y.part) - 0.57722 * sigma.tmp
sigma=c(sigma,sigma.tmp)
mu=c(mu,mu.tmp)
}
xi = 0.1
return(c(xi,sigma,mu))
}
x=data[,1]
y=data[,2]
theta <- get.start.val(data)
#####negativeloglikelihod function vor gev-input, when having same xi
#tmp contains x and y values
negloglik <- function(theta, tmp) {
x=tmp[,1]
stress=unique(x)
y=tmp[,2]
xi=theta[1]
sigma.v=theta[2:(length(stress)+1)]
mu.v=theta[(length(stress)+2):(2*length(stress)+1)]
out=0
for(j in 1: length(stress)){
mu=mu.v[j]
sigma=sigma.v[j]
y.part=part(y,x==stress[j])
v <- 1 + (xi * (y.part - mu))/sigma
#print(v)
#print(sigma)
if ((sigma < 0) || (min(v) < 0))
out = out + 1e+06
else {
term1 <- length(y.part) * logb(sigma)
term2 <- sum((1 + 1/xi) * logb(v))
term3 <- sum(v^(-1/xi))
out = out + term1 + term2 + term3
}
}
out
}
if (is.na(control)) {
fit = optim(theta, negloglik, tmp = data)
} else {
fit = optim(theta, negloglik,  control , tmp = data)
}
if (fit$convergence)
warning("optimization may not have succeeded")
par.ests.all <- fit$par
par.ests = list(xi=par.ests.all[1], sigma=par.ests.all[1:length(unique(x))+1], mu = par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
standardize<-function(x,y,xi,sigma,mu){
y.new=c()
stress=unique(x)
for(j in 1:length(x)){
pos=which(x[j]==stress)
y.new=c(y.new,(y[j]-mu[pos])/sigma[pos])
}
return(y.new)
}
y.new=standardize(x,y,par.ests.all[1],par.ests.all[1:length(unique(x))+1],par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
out <- list(x=x, y=y, y.std=y.new,
par.ests = par.ests, counts=fit$counts,
converged = fit$convergence, nllh.final = fit$value)
#names(out$par.ests) <- c("xi", "sigma", "mu")
#names(out$par.ses) <- c("xi", "sigma", "mu")
#class(out) <- "gev2"
out
}
z=gev.xi.same(shen1)
control = list(maxit=1000)
z=gev.xi.same(shen1, control)
##parameter-estimate function vor gev-input, when having same xi
gev.xi.same<-function (data, control=NA)
{
######calculate start value for optim
get.start.val<-function(data){
x=data[,1]
stress=unique(x)
y=data[,2]
sigma=c()
mu=c()
for(j in 1:length(stress)){
y.part=part(y,x==stress[j])
sigma.tmp=sqrt(6 * var(y.part))/pi
mu.tmp <- mean(y.part) - 0.57722 * sigma.tmp
sigma=c(sigma,sigma.tmp)
mu=c(mu,mu.tmp)
}
xi = 0.1
return(c(xi,sigma,mu))
}
x=data[,1]
y=data[,2]
theta <- get.start.val(data)
#####negativeloglikelihod function vor gev-input, when having same xi
#tmp contains x and y values
negloglik <- function(theta, tmp) {
x=tmp[,1]
stress=unique(x)
y=tmp[,2]
xi=theta[1]
sigma.v=theta[2:(length(stress)+1)]
mu.v=theta[(length(stress)+2):(2*length(stress)+1)]
out=0
for(j in 1: length(stress)){
mu=mu.v[j]
sigma=sigma.v[j]
y.part=part(y,x==stress[j])
v <- 1 + (xi * (y.part - mu))/sigma
#print(v)
#print(sigma)
if ((sigma < 0) || (min(v) < 0))
out = out + 1e+06
else {
term1 <- length(y.part) * logb(sigma)
term2 <- sum((1 + 1/xi) * logb(v))
term3 <- sum(v^(-1/xi))
out = out + term1 + term2 + term3
}
}
out
}
print(control)
if (is.na(control)) {
fit = optim(theta, negloglik, tmp = data)
} else {
fit = optim(theta, negloglik,  control , tmp = data)
}
if (fit$convergence)
warning("optimization may not have succeeded")
par.ests.all <- fit$par
par.ests = list(xi=par.ests.all[1], sigma=par.ests.all[1:length(unique(x))+1], mu = par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
standardize<-function(x,y,xi,sigma,mu){
y.new=c()
stress=unique(x)
for(j in 1:length(x)){
pos=which(x[j]==stress)
y.new=c(y.new,(y[j]-mu[pos])/sigma[pos])
}
return(y.new)
}
y.new=standardize(x,y,par.ests.all[1],par.ests.all[1:length(unique(x))+1],par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
out <- list(x=x, y=y, y.std=y.new,
par.ests = par.ests, counts=fit$counts,
converged = fit$convergence, nllh.final = fit$value)
#names(out$par.ests) <- c("xi", "sigma", "mu")
#names(out$par.ses) <- c("xi", "sigma", "mu")
#class(out) <- "gev2"
out
}
control = list(maxit=1000)
z=gev.xi.same(shen1, control)
gev.xi.same<-function (data, control=NA)
{
######calculate start value for optim
get.start.val<-function(data){
x=data[,1]
stress=unique(x)
y=data[,2]
sigma=c()
mu=c()
for(j in 1:length(stress)){
y.part=part(y,x==stress[j])
sigma.tmp=sqrt(6 * var(y.part))/pi
mu.tmp <- mean(y.part) - 0.57722 * sigma.tmp
sigma=c(sigma,sigma.tmp)
mu=c(mu,mu.tmp)
}
xi = 0.1
return(c(xi,sigma,mu))
}
x=data[,1]
y=data[,2]
theta <- get.start.val(data)
#####negativeloglikelihod function vor gev-input, when having same xi
#tmp contains x and y values
negloglik <- function(theta, tmp) {
x=tmp[,1]
stress=unique(x)
y=tmp[,2]
xi=theta[1]
sigma.v=theta[2:(length(stress)+1)]
mu.v=theta[(length(stress)+2):(2*length(stress)+1)]
out=0
for(j in 1: length(stress)){
mu=mu.v[j]
sigma=sigma.v[j]
y.part=part(y,x==stress[j])
v <- 1 + (xi * (y.part - mu))/sigma
#print(v)
#print(sigma)
if ((sigma < 0) || (min(v) < 0))
out = out + 1e+06
else {
term1 <- length(y.part) * logb(sigma)
term2 <- sum((1 + 1/xi) * logb(v))
term3 <- sum(v^(-1/xi))
out = out + term1 + term2 + term3
}
}
out
}
print(control)
if (is.na(control)) {
fit = optim(theta, negloglik, tmp = data)
} else {
fit = optim(theta, negloglik, tmp = data,  control=control)
}
if (fit$convergence)
warning("optimization may not have succeeded")
par.ests.all <- fit$par
par.ests = list(xi=par.ests.all[1], sigma=par.ests.all[1:length(unique(x))+1], mu = par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
standardize<-function(x,y,xi,sigma,mu){
y.new=c()
stress=unique(x)
for(j in 1:length(x)){
pos=which(x[j]==stress)
y.new=c(y.new,(y[j]-mu[pos])/sigma[pos])
}
return(y.new)
}
y.new=standardize(x,y,par.ests.all[1],par.ests.all[1:length(unique(x))+1],par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
out <- list(x=x, y=y, y.std=y.new,
par.ests = par.ests, counts=fit$counts,
converged = fit$convergence, nllh.final = fit$value)
#names(out$par.ests) <- c("xi", "sigma", "mu")
#names(out$par.ses) <- c("xi", "sigma", "mu")
#class(out) <- "gev2"
out
}
z=gev.xi.same(shen1)
control = list(maxit=1000)
z=gev.xi.same(shen1, control)
z$count
gev.xi.same<-function (data, control=NA)
{
######calculate start value for optim
get.start.val<-function(data){
x=data[,1]
stress=unique(x)
y=data[,2]
sigma=c()
mu=c()
for(j in 1:length(stress)){
y.part=part(y,x==stress[j])
sigma.tmp=sqrt(6 * var(y.part))/pi
mu.tmp <- mean(y.part) - 0.57722 * sigma.tmp
sigma=c(sigma,sigma.tmp)
mu=c(mu,mu.tmp)
}
xi = 0.1
return(c(xi,sigma,mu))
}
x=data[,1]
y=data[,2]
theta <- get.start.val(data)
#####negativeloglikelihod function vor gev-input, when having same xi
#tmp contains x and y values
negloglik <- function(theta, tmp) {
x=tmp[,1]
stress=unique(x)
y=tmp[,2]
xi=theta[1]
sigma.v=theta[2:(length(stress)+1)]
mu.v=theta[(length(stress)+2):(2*length(stress)+1)]
out=0
for(j in 1: length(stress)){
mu=mu.v[j]
sigma=sigma.v[j]
y.part=part(y,x==stress[j])
v <- 1 + (xi * (y.part - mu))/sigma
#print(v)
#print(sigma)
if ((sigma < 0) || (min(v) < 0))
out = out + 1e+06
else {
term1 <- length(y.part) * logb(sigma)
term2 <- sum((1 + 1/xi) * logb(v))
term3 <- sum(v^(-1/xi))
out = out + term1 + term2 + term3
}
}
out
}
if (is.na(control)) {
fit = optim(theta, negloglik, tmp = data)
} else {
fit = optim(theta, negloglik, tmp = data,  control=control)
}
if (fit$convergence)
warning("optimization may not have succeeded")
par.ests.all <- fit$par
par.ests = list(xi=par.ests.all[1], sigma=par.ests.all[1:length(unique(x))+1], mu = par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
standardize<-function(x,y,xi,sigma,mu){
y.new=c()
stress=unique(x)
for(j in 1:length(x)){
pos=which(x[j]==stress)
y.new=c(y.new,(y[j]-mu[pos])/sigma[pos])
}
return(y.new)
}
y.new=standardize(x,y,par.ests.all[1],par.ests.all[1:length(unique(x))+1],par.ests.all[(length(unique(x))+2):(2*length(unique(x))+1)])
out <- list(x=x, y=y, y.std=y.new,
par.ests = par.ests, counts=fit$counts,
converged = fit$convergence, nllh.final = fit$value)
#names(out$par.ests) <- c("xi", "sigma", "mu")
#names(out$par.ses) <- c("xi", "sigma", "mu")
#class(out) <- "gev2"
out
}
control = list(maxit=10000)
z=gev.xi.same(shen1, control)
z$count
z
p=shen1
p[,2]=z$y.std
z2=gev.xi.same(p)
z2=gev.xi.same(p,control)
control = list(maxit=100000)
z2=gev.xi.same(p,control)
z2
z
plot(shen[,1],z$y.ind)
plot(shen[,1],z$y.std)
plot(shen1[,1],z$y.std)
#gev-distribution
gev.ind.est<-function(x,y){
xi=c()
sigma=c()
mu=c()
stress=c()
for(i in 1:length(unique(x))){
parTmp=c(NA,NA,NA)
try({
ytmp=part(y,x==unique(x)[i]);
parTmp=suppressWarnings(gev(ytmp)$par.ests)
xi=c(xi,parTmp[[1]])
sigma=c(sigma,parTmp[[2]])
mu=c(mu,parTmp[[3]])
stress=c(stress,unique(x)[i])
},TRUE)
}
par=data.frame(stress,xi,mu,sigma)
return(par)
}
#gev-distribution
gev.ind.est<-function(x,y){
xi=c()
sigma=c()
mu=c()
stress=c()
for(i in 1:length(unique(x))){
parTmp=c(NA,NA,NA)
try({
ytmp=part(y,x==unique(x)[i]);
parTmp=suppressWarnings(gev(ytmp)$par.ests)
xi=c(xi,parTmp[[1]])
sigma=c(sigma,parTmp[[2]])
mu=c(mu,parTmp[[3]])
stress=c(stress,unique(x)[i])
},TRUE)
}
par=data.frame(stress,xi,mu,sigma)
return(par)
}
ind=gev.ind.est(shen1[,1],z$y.std)
ind
p[,2]=z$y.std
z2=gev.xi.same(p, control)
#plot std^2 values
plot(shen1[,1],z2$y.std)
#fit std^2 values
ind=gev.ind.est(shen1[,1],z2$y.std)
ind2=gev.ind.est(shen1[,1],z2$y.std)
ind=gev.ind.est(shen1[,1],z$y.std)
ind2
plot(shen1[,1],z$y.std)
plot(shen1[,1],z2$y.std)
plot(shen1[,1],z$y.std)
abline(0,0,col="red")
ks.test.all=function(x,y){
stress=unique(x)
m=matrix(rep(NA,length(stress)^2),nrow=lenght(stress))
return(m)
}
ks=ks.test.all(shen1[,1],z$y.std)
ks.test.all=function(x,y){
stress=unique(x)
m=matrix(rep(NA,length(stress)^2),nrow=length(stress))
return(m)
}
ks=ks.test.all(shen1[,1],z$y.std)
ks
ks.test(1:100,1:100)
r=ks.test(1:100,1:100)
names(r)
r$p.value
ks.test.all=function(x,y){
stress=unique(x)
m=matrix(rep(NA,length(stress)^2),nrow=length(stress))
for(j in 1:length(stress)){
d1=part(y,x==stress[j])
for(i in 1:length(stress)){
d2=part(y,x==stress[i])
m[i,j]=ks.test(d1,d2)$p.value
}
}
return(m)
}
ks=ks.test.all(shen1[,1],z$y.std)
ks
ks.test.all=function(x,y){
stress=unique(x)
m=matrix(rep(NA,length(stress)^2),nrow=length(stress))
for(j in 1:length(stress)){
d1=part(y,x==stress[j])
for(i in 1:length(stress)){
d2=part(y,x==stress[i])
m[i,j]=suppressWarnings(ks.test(d1,d2)$p.value)
}
}
return(m)
}
ks=ks.test.all(shen1[,1],z$y.std)
ks
ks
ind.all=gev.ind.est(shen1[,1],z$y.std)
ind=gev(z$y.std)
ind.all
ind
ind=gev(z$y.std)$par.ests
ind
ind.all
