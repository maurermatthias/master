{
    "contents" : "#source('function.R')\nlibrary('stats')\nlibrary('evir')\n\n###################################################################\n#function gets a named list\n#NEEDED:\n#distr .... distribution of the observations\n#xval ..... predictor values as vector\n#yval ..... observation values as vector\n#struct.fun...list of function names for modelling parameter structure (one name for each parameter)\n#struct.start.parameter....start parameter vector for ls-optimization (see par - optim)\n#OPTIONAL:\n#type  .........diag/fit; std=fit; if type is diag no fit is performed - only the individual estimates are ploted\n#error.type ... if rel then relative errors are used, if wei the error is weighted with the mean, abs is standard for the ls-optimization\n#control.......  named-list for optim (see control - optim)\n#validity.fun .. name of function returning true, if parameter fulfill requirements, false otherwise\npr<-function(x){\n  \n  ###################################################################\n  ###################################################################\n  #Functions needed for pr\n  \n  ###################################################################\n  #helper functions\n  \n  #takes two vektors of the same size, returns those elements of vector\n  #one where vector two contains true\n  part<-function(data,bool)\n  {\n    if(length(bool)!=length(data))\n      stop(\"vectors need to be of the same size!\") \n    ret=c()\n    for(i in 1:length(bool))\n      if(bool[i])\n        ret[length(ret)+1]=data[i]\n    ret\n  }\n  \n  #supress only special warning\n  suppressWarnings2<-function(expr, regex=character()){\n    withCallingHandlers(expr, warning=function(w) {\n      if (length(regex) == 1 && length(grep(regex, conditionMessage(w)))) {\n        invokeRestart(\"muffleWarning\")\n      }\n    })\n  } \n  \n  #evaluates function with name \"fun\" at each point in vector xval and parameter par \n  myapply<-function(fun,xval,par){\n    func=match.fun(fun);\n    val=c()\n    for(i in 1:length(xval)){\n      val=c(val,func(xval[i],par));\n    }\n    return(val)\n  }\n  \n  \n  \n  ###################################################################\n  #checks input for the function pr \n  checkInput<-function(x,allowedDistributions){\n    #check distribution input\n    if(is.null(x[[\"distr\"]]))\n      stop(\"Distribution (distr) of observations not specified!\");\n    if(typeof(x[[\"distr\"]]) != \"character\")\n      stop(\"Distribution (distr) needs to be a character-type!\")\n    if(sum(allowedDistributions==x[[\"distr\"]])==0)\n      stop(paste(\"Distribution (distr) \",x[[\"distr\"]],\" not supported!\",sep=\"\"))\n    #check data (observations/predictors) input\n    if(is.null(x[[\"xval\"]]))\n      stop(\"Predictor values (xval) of observations not specified!\");\n    if(is.null(x[[\"yval\"]]))\n      stop(\"observation values (yval) not specified!\");\n    if(length(x[[\"xval\"]]) != length(x[[\"yval\"]]))\n      stop(\"Predictor values (xval) and observation values (yval) vectorlength differ!\"); \n    if(typeof(x[[\"xval\"]]) != \"double\" || typeof(x[[\"yval\"]]) != \"double\")\n      stop(\"Predictor values (xval) and observation values (yval) needs to be a double-type!\");\n  }\n  \n  ###################################################################\n  #Parameter estimators for each stress level\n  \n  #estimate normal-distribution parameter\n  #adjusted ML-estimators (adjusted sample variance instead of sample variance)\n  estimateParameters.norm<-function(x){\n    predictor.levels=unique(x[[\"xval\"]])\n    p1=c();\n    p2=c();\n    for(i in 1:length(predictor.levels)){\n      data=part(x[[\"yval\"]],x[[\"xval\"]]==predictor.levels[i]);\n      if(length(data)<=2)\n        stop(\"For each predictor-value (xval) there need to be at least two observations for the estimation!\");\n      p1=c(p1,mean(data));\n      p2=c(p2,sd(data));\n    }\n    ret=list();\n    ret[[\"distribution\"]]=\"norm\";\n    ret[[\"numberOfParameters\"]]=2;\n    ret[[\"predictorlevels\"]]=predictor.levels;\n    ret[[\"parameter.name\"]]=c(\"mu\",\"sigma\")\n    ret[[\"p1\"]]=p1;\n    ret[[\"p2\"]]=p2;\n    ret[[\"p\"]]=t(array(c(p1,p2),dim=c(length(p1),2)));\n    return(ret);\n  }\n  \n  #estimate log normal-distribution parameter\n  #adjusted ML-estimators (adjusted sample variance instead of sample variance)\n  estimateParameters.logn<-function(x){\n    predictor.levels=unique(x[[\"xval\"]])\n    p1=c();\n    p2=c();\n    for(i in 1:length(predictor.levels)){\n      data=part(x[[\"yval\"]],x[[\"xval\"]]==predictor.levels[i]);\n      if(length(data)<=2)\n        stop(\"For each predictor-value (xval) there need to be at least two observations for the estimation!\");\n      p1=c(p1,mean(log(data)));\n      p2=c(p2,sd(log(data)));\n    }\n    ret=list();\n    ret[[\"distribution\"]]=\"logn\";\n    ret[[\"numberOfParameters\"]]=2;\n    ret[[\"predictorlevels\"]]=predictor.levels;\n    ret[[\"parameter.name\"]]=c(\"mu\",\"sigma\")\n    ret[[\"p1\"]]=p1;\n    ret[[\"p2\"]]=p2;\n    ret[[\"p\"]]=t(array(c(p1,p2),dim=c(length(p1),2)));\n    return(ret);\n  }\n  \n  #estimate gev distribution parameter\n  estimateParameters.gev<-function(x){\n    predictor.levels=unique(x[[\"xval\"]])\n    p1=c();\n    p2=c();\n    p3=c();\n    for(i in 1:length(predictor.levels)){\n      data=part(x[[\"yval\"]],x[[\"xval\"]]==predictor.levels[i]);\n      if(length(data)<=3)\n        stop(\"For each predictor-value (xval) there need to be at least three observations for the estimation!\");\n      p.est=gev(data,1)$par.est\n      p1=c(p1,p.est[[1]]);\n      p2=c(p2,p.est[[2]]);\n      p3=c(p3,p.est[[3]]);\n    }\n    ret=list();\n    ret[[\"distribution\"]]=\"gev\";\n    ret[[\"numberOfParameters\"]]=3;\n    ret[[\"predictorlevels\"]]=predictor.levels;\n    ret[[\"parameter.name\"]]=c(\"xi\",\"sigma\",\"mu\")\n    ret[[\"p1\"]]=p1;\n    ret[[\"p2\"]]=p2;\n    ret[[\"p3\"]]=p3;\n    ret[[\"p\"]]=t(array(c(p1,p2,p3),dim=c(length(p1),3)));\n    return(ret);\n  }\n  \n  #estimate gamma distribution parameter\n  estimateParameters.gamma<-function(x){\n    predictor.levels=unique(x[[\"xval\"]])\n    p1=c();\n    p2=c();\n    for(i in 1:length(predictor.levels)){\n      data=part(x[[\"yval\"]],x[[\"xval\"]]==predictor.levels[i]);\n      if(length(data)<=3)\n        stop(\"For each predictor-value (xval) there need to be at least three observations for the estimation!\");\n      #moment estimators:\n      m1=sum(data)/length(data)\n      m2=sum(data^2)/length(data)\n      k=m1^2/(m2-m1^2)\n      beta=m1/(m2-m1^2)\n      theta=1/beta  #f(x,k,theta)=(x^(k-1)e^(-x/theta))/(Gamma(k)theta^k)\n      #moment est. end\n      p1=c(p1,k);\n      p2=c(p2,theta);\n    }\n    ret=list();\n    ret[[\"distribution\"]]=\"gamma\";\n    ret[[\"numberOfParameters\"]]=2;\n    ret[[\"predictorlevels\"]]=predictor.levels;\n    ret[[\"parameter.name\"]]=c(\"k\",\"theta\")\n    ret[[\"p1\"]]=p1;\n    ret[[\"p2\"]]=p2;\n    ret[[\"p\"]]=t(array(c(p1,p2),dim=c(length(p1),2)));\n    return(ret);\n  }\n  \n  #estimates parameter for the observations for each predictor level\n  estimateParameters<-function(x){\n    if(x[[\"distr\"]]==\"norm\"){\n      return(estimateParameters.norm(x));\n    }else if(x[[\"distr\"]]==\"logn\"){\n      return(estimateParameters.logn(x));\n    }else if(x[[\"distr\"]]==\"gev\"){\n      return(estimateParameters.gev(x));\n    }else if(x[[\"distr\"]]==\"gamma\"){\n      return(estimateParameters.gamma(x));\n    }else{\n      stop(paste(\"Distribution (distr) \",x[[\"distr\"]],\" - no parameter estimation implemented so far!\",sep=\"\"));\n    }\n  }\n  \n  \n  ###################################################################\n  #estimation of structure parameter with LS methode\n  \n  #least square error function for optimization\n  error.ls<-function(parameter,data){\n    x=data[[1]];\n    if(!is.null(x[[\"validity.fun\"]])){\n      val.fun=match.fun(x[[\"validity.fun\"]]);\n      if(!val.fun(x[[\"xval\"]],parameter)){\n        return(Inf);\n      }\n    }\n    ind.par.est=data[[2]];\n    parameter.fun.name = x[[\"struct.fun\"]]\n    error.value=0;\n    p=ind.par.est[[\"p\"]]\n    predictorlevels=ind.par.est[[\"predictorlevels\"]]\n    if(length(parameter.fun.name) != ind.par.est[[\"numberOfParameters\"]])\n      stop(\"Number of Parameter do not fit number of Parameter-structure-function supplied!\");\n    for(i in 1:length(parameter.fun.name)){\n      fun=match.fun(parameter.fun.name[i]);\n      for(j in 1:length(predictorlevels)){\n        structure.value=fun(predictorlevels[j],parameter);\n        #if(structure.value < 0)\n        #  return(Inf);\n        if(!is.null(x[[\"error.type\"]]) && x[[\"error.type\"]]==\"rel\"){\n          #relative error\n          error.value=error.value+((p[i,j]-structure.value)/p[i,j])^2;\n        }else if(!is.null(x[[\"error.type\"]]) && x[[\"error.type\"]]==\"wei\"){\n          #weigthed error - weigth are mean of values\n          error.value=error.value+((p[i,j]-structure.value)/sum(p[i,]))^2;\n        }else{\n          #absolute error\n          error.value=error.value+((p[i,j]-structure.value))^2;\n        }\n      }   \n    }\n    return(error.value);\n  }\n  \n  #uses grid search to find error.ls-function parameter for finite function value \n  grid.search<-function(data){\n    max.it=25;\n    start.delta=10;\n    x=data[[1]];\n    ind.par.est=data[[2]];\n    stop(\"Grid search not implemented yet.\");\n  }\n  \n  find.start.par<-function(data){\n    if(is.null(data[[1]][[\"struct.start.parameter\"]])){\n      #grid.search(data);\n      stop(\"No initial structure-parameter (struct.start.parameter) for optimization provided!\");\n    }else{\n      return(data[[1]][[\"struct.start.parameter\"]]);\n    }\n  }\n  \n  estimateStructureParameter<-function(x,ind.par.est){\n    if(is.null(x[[\"control\"]])){\n      control = list(maxit = 1000);\n    }else{\n      control = x[[\"control\"]];\n    }\n    data=list(x,ind.par.est);\n    start.par=find.start.par(data);\n    o.result=suppressWarnings(optim(start.par,fn=error.ls,data=data, control=control))\n    return(o.result);\n  }\n  \n  \n  ##########################Chi2 test\n  \n  chi2.test<-function(val){\n    a=list();\n    a[[\"quantiles\"]]=val[[\"input\"]][[\"quantile\"]]\n    a[[\"quantile.values\"]]=getQuantileValues(val);\n    a[[\"quantile.numbers\"]]=getQuantileNumbers(val[[\"input\"]][[\"xval\"]],val[[\"input\"]][[\"yval\"]],val[[\"input\"]][[\"quantiles\"]],a[[\"quantile.values\"]]);\n    a[[\"chi2.value\"]]=getChi2Value(val[[\"input\"]][[\"quantiles\"]],a[[\"quantile.numbers\"]])\n    a[[\"df\"]]=length(val[[\"input\"]][[\"xval\"]])\n    if(is.null(val[[\"input\"]][[\"sim\"]]) || ( !is.null(val[[\"input\"]][[\"sim\"]]) && !val[[\"input\"]][[\"sim\"]]))\n      warning(\"Degrees of freedom for chi2 test not corrected yet!\");\n    a[[\"p.value\"]]=pchisq(a[[\"chi2.value\"]],a[[\"df\"]]);\n    \n    return(a)\n  }\n  \n  getChi2Value = function(quantiles,quantile.numbers){\n    no.stress=dim(quantile.numbers)[1]-1\n    no.quantile.areas=dim(quantile.numbers)[2]-1\n    no.observations=sum(quantile.numbers)-sum(quantile.numbers[1])\n    observed=c()\n    expected=c()\n    for(i in 1:no.quantile.areas){\n      observed=c(observed,sum(quantile.numbers[[i+1]]))\n      if(i==1){\n        expected=c(expected,quantiles[1])\n      }else if(i==no.quantile.areas){\n        expected=c(expected,1-quantiles[i-1])\n      }else{\n        expected=c(expected,quantiles[i]-quantiles[i-1])\n      }\n    }\n    expected=expected*no.observations\n    val=sum((observed-expected)^2/expected)\n    return(val)\n  }\n  \n  #x...xval to be tested\n  #y...yval to be tested\n  #quantiles....vector of qunatile area e.g.: c(0.25,0.5,0.75)\n  #qunatileValues....values of the corresponding quantile (per stresslevel)\n  getQuantileNumbers<-function(x,y,quantiles,quantileValues){\n    stress=unique(x);\n    A=matrix(rep(0,(length(stress)+1)*(length(quantiles)+1)),nrow=(length(stress)+1),ncol=(length(quantiles)+1));\n    for(i in 1:length(stress)){\n      data=part(y,x==stress[i])\n      for(j in 1:(length(quantiles)+1)){\n        if(j==1){\n          A[i,j]=sum(data<quantileValues[i,j+1])\n        }else if(j==(length(quantiles)+1)){\n          A[i,j]=sum(data >= quantileValues[i,j])\n        }else{\n          A[i,j]=sum(data<quantileValues[i,j+1] & data >= quantileValues[i,j])\n        }\n        \n      }\n    }\n    for(j in 1:(length(quantiles)+1)){\n      A[length(stress)+1,j]=sum(A[,j])\n    }\n    \n    df=data.frame(c(stress,0))\n    for(i in 1:(length(quantiles)+1)){\n      if(i==1){\n        df[[paste(\"q_0-q_\",as.character(quantiles[i]), sep= \"\")]]=A[,i];\n      }else if(i==(length(quantiles)+1)){\n        df[[paste(\"q_\",as.character(quantiles[i-1]),\"-q_1\", sep= \"\")]]=A[,i];\n      }else{\n        df[[paste(\"q_\",as.character(quantiles[i-1]),\"-q_\",as.character(quantiles[i]), sep= \"\")]]=A[,i];\n      }\n    }\n    return(df);\n    \n  }\n  \n  \n  getQuantileValues<-function(val){\n    stress=unique(val[[\"input\"]][[\"xval\"]]);\n    quantiles=val[[\"input\"]][[\"quantiles\"]];\n    struct.parameter=val[[\"struct.par.est\"]]\n    parameter.function.name=val[[\"input\"]][[\"struct.fun\"]]\n    nr.dist.parameter=val[[\"ind.par.est\"]][[\"numberOfParameters\"]]\n    \n    #calculate distribution parameters for each stress level\n    dist.parameter=matrix(rep(0,nr.dist.parameter*length(stress)),nrow=length(stress), ncol=nr.dist.parameter)\n    for(j in 1:nr.dist.parameter){\n      fun=match.fun(parameter.function.name[j]);\n      for(i in 1:length(stress)){\n        dist.parameter[i,j]=fun(stress[i],struct.parameter);\n      }\n    }\n    \n    #calculate quantile values for each stress level \n    A=matrix(rep(0,length(stress)*length(quantiles)),nrow=length(stress),ncol=length(quantiles));\n    for(i in 1:length(stress)){\n      parameter=dist.parameter[i,];\n      for(j in 1:length(quantiles)){\n        if(val[[\"input\"]][[\"distr\"]]==\"norm\"){\n          A[i,j]=qnorm(quantiles[j],parameter[1],parameter[2]);\n        }else if(val[[\"input\"]][[\"distr\"]]==\"logn\"){\n          A[i,j]=qlnorm(quantiles[j],parameter[1],parameter[2]);\n        }else if(val[[\"input\"]][[\"distr\"]]==\"gev\"){\n          A[i,j]=qgev(quantiles[j],parameter[1],parameter[3],parameter[2]);\n        }else if(val[[\"input\"]][[\"distr\"]]==\"gamma\"){\n          A[i,j]=qgamma(quantiles[j],parameter[1],scale=parameter[2]);\n        }else{\n          stop(\"Chi2 test not implemented with this distribution!\");\n        }\n      }\n    }\n    df=data.frame(stress)\n    for(i in 1:length(quantiles)){\n      df[[paste(\"q_\",as.character(quantiles[i]), sep= \"\")]]=A[,i];\n    }\n    return(df);\n  }\n  \n  #plot the parameter calculatet - x is the return value from pr\n  pr.parplot<-function(x){\n    ############################################################################\n    #pr.parplot needed functions\n    \n    #takes two vektors of the same size, returns those elements of vector\n    #one where vector two contains true\n    part<-function(data,bool)\n    {\n      if(length(bool)!=length(data))\n        stop(\"vectors need to be of the same size!\") \n      ret=c()\n      for(i in 1:length(bool))\n        if(bool[i])\n          ret[length(ret)+1]=data[i]\n      ret\n    }\n    \n    #evaluates function with name \"fun\" at each point in vector xval and parameter par \n    myapply<-function(fun,xval,par){\n      func=match.fun(fun);\n      val=c()\n      for(i in 1:length(xval)){\n        val=c(val,func(xval[i],par));\n      }\n      return(val)\n    }\n    \n    #####################PLOT\n    #plot the 2 parameter calculatet - x is the return value from pr \n    pr.parplot2<-function(x){\n      input=x[[\"input\"]];\n      type=input[[\"type\"]]\n      ind.par.est=x[[\"ind.par.est\"]];\n      struct.par.est=x[[\"struct.par.est\"]];\n      \n      x.points=ind.par.est[[\"predictorlevels\"]]\n      y.points1=ind.par.est[[\"p\"]][1,]\n      y.points2=ind.par.est[[\"p\"]][2,]\n      #xmin=max(min(input[[\"xval\"]])*0.9,struct.par.est[1]+0.0000001);\n      xmin=min(input[[\"xval\"]])*0.9;\n      xmax=max(input[[\"xval\"]])*1.1\n      x.lineTMP1=(0:1000)*(xmax-xmin)/1000+xmin\n      x.lineTMP=c(x.lineTMP1,rev(x.lineTMP1));\n      \n      if(type==\"fit\"){\n        parameter.fun.name = input[[\"struct.fun\"]];\n        #fun1=match.fun(parameter.fun.name[1]);\n        #fun2=match.fun(parameter.fun.name[2]);\n        y.line1TMP=myapply(parameter.fun.name[1], x.lineTMP, struct.par.est);\n        y.line2TMP=myapply(parameter.fun.name[2], x.lineTMP, struct.par.est);\n        #y.line1TMP=fun1(x.lineTMP,struct.par.est);\n        #y.line2TMP=fun2(x.lineTMP,struct.par.est);\n        \n        boolv=(!is.na(y.line1TMP)) & (!is.na(y.line2TMP))\n        if(input[[\"distr\"]]==\"norm\"  || input[[\"distr\"]]==\"logn\")\n          boolv= boolv & ((y.line1TMP>=0) & ( y.line2TMP>=0));\n        x.line=part(x.lineTMP,boolv);\n        y.line1=part(y.line1TMP,boolv);\n        y.line2=part(y.line2TMP,boolv);\n      }\n      \n      if(!is.null(ind.par.est[[\"parameter.name\"]])){\n        name1=ind.par.est[[\"parameter.name\"]][1]\n        name2=ind.par.est[[\"parameter.name\"]][2]\n      }else{\n        name1=\"parameter1\";\n        name2=\"parameter2\";\n      }\n      \n      #x.line=x.lineTMP\n      #y.line1=y.line1TMP\n      #y.line2=y.line2TMP\n      \n      #create new plot\n      plot.new()\n      \n      #plot first parameter\n      par(fig=c(0,1,0.4,1), new=TRUE)\n      plot(x.points,y.points1,xlab=\"\",ylab=name1)\n      if(type==\"fit\"){\n        polygon(x.line,y.line1,border=\"red\")\n        legend(x=\"topright\", legend=c(paste(\"estimate \",name1, sep=\"\"),paste(\"observation \",name1, sep=\"\")), col = c(\"red\",\"black\"), lty = c(\"solid\",NA), pch=c(NA,\"o\"))\n      }\n      \n      #plot second parameter\n      par(fig=c(0,1,0,0.6), new=TRUE)\n      plot(x.points,y.points2,xlab=\"stress\",ylab=name2)\n      if(type==\"fit\"){\n        polygon(x.line,y.line2,border=\"red\")\n        legend(x=\"topright\", legend=c(paste(\"estimate \",name2, sep=\"\"),paste(\"observation \",name2, sep=\"\")), col = c(\"red\",\"black\"), lty = c(\"solid\",NA), pch=c(NA,\"o\"))\n      }\n    }\n    \n    #plot the 3 parameter calculatet - x is the return value from pr \n    pr.parplot3<-function(x){\n      input=x[[\"input\"]];\n      type=input[[\"type\"]]\n      ind.par.est=x[[\"ind.par.est\"]];\n      struct.par.est=x[[\"struct.par.est\"]];\n      \n      x.points=ind.par.est[[\"predictorlevels\"]]\n      y.points1=ind.par.est[[\"p\"]][1,]\n      y.points2=ind.par.est[[\"p\"]][2,]\n      y.points3=ind.par.est[[\"p\"]][3,]\n      xmin=min(input[[\"xval\"]])*0.9;\n      xmax=max(input[[\"xval\"]])*1.1\n      x.lineTMP1=(0:1000)*(xmax-xmin)/1000+xmin\n      x.lineTMP=c(x.lineTMP1,rev(x.lineTMP1));\n      \n      if(type==\"fit\"){\n        parameter.fun.name = input[[\"struct.fun\"]];\n        #fun1=match.fun(parameter.fun.name[1]);\n        #fun2=match.fun(parameter.fun.name[2]);\n        y.line1TMP=myapply(parameter.fun.name[1], x.lineTMP, struct.par.est);\n        y.line2TMP=myapply(parameter.fun.name[2], x.lineTMP, struct.par.est);\n        y.line3TMP=myapply(parameter.fun.name[3], x.lineTMP, struct.par.est);\n        #y.line1TMP=fun1(x.lineTMP,struct.par.est);\n        #y.line2TMP=fun2(x.lineTMP,struct.par.est);\n        \n        \n        boolv = (!is.na(y.line1TMP)) & (!is.na(y.line2TMP)) & (!is.na(y.line3TMP))\n        if(input[[\"distr\"]]==\"gev\")\n          boolv = boolv & ((y.line2TMP>=0) & ( y.line3TMP>=0))\n        \n        x.line=part(x.lineTMP,boolv);\n        y.line1=part(y.line1TMP,boolv);\n        y.line2=part(y.line2TMP,boolv);\n        y.line3=part(y.line3TMP,boolv);\n        \n        #x.line=x.lineTMP\n        #y.line1=y.line1TMP\n        #y.line2=y.line2TMP\n        #y.line3=y.line3TMP\n      }\n      \n      if(!is.null(ind.par.est[[\"parameter.name\"]])){\n        name1=ind.par.est[[\"parameter.name\"]][1]\n        name2=ind.par.est[[\"parameter.name\"]][2]\n        name3=ind.par.est[[\"parameter.name\"]][3]\n      }else{\n        name1=\"parameter1\";\n        name2=\"parameter2\";\n        name3=\"parameter3\";\n      }\n      \n      #create new plot\n      plot.new()\n      d=0.225\n      \n      #plot first parameter\n      par(fig=c(0,1,1-2*d,1), new=TRUE)\n      plot(x.points,y.points1,xlab=\"\",ylab=name1)\n      if(type==\"fit\"){\n        polygon(x.line,y.line1,border=\"red\")\n        legend(x=\"topright\", legend=c(paste(\"estimate \", name1, sep=\"\"),paste(\"observation \", name1, sep=\"\")), col = c(\"red\",\"black\"), lty = c(\"solid\",NA), pch=c(NA,\"o\"))\n      }\n      \n      #plot second parameter\n      par(fig=c(0,1,0.5-d,0.5+d), new=TRUE)\n      plot(x.points,y.points2,xlab=\"\",ylab=name2)\n      if(type==\"fit\"){\n        polygon(x.line,y.line2,border=\"red\")\n        legend(x=\"topright\", legend=c(paste(\"estimate \", name2, sep=\"\"),paste(\"observation \", name2, sep=\"\")), col = c(\"red\",\"black\"), lty = c(\"solid\",NA), pch=c(NA,\"o\"))\n      }\n      \n      #plot third parameter\n      par(fig=c(0,1,0,2*d), new=TRUE)\n      plot(x.points,y.points3,xlab=\"stress\",ylab=name3)\n      if(type==\"fit\"){\n        polygon(x.line,y.line3,border=\"red\")\n        legend(x=\"topright\", legend=c(paste(\"estimate \", name3, sep=\"\"),paste(\"observation \", name3, sep=\"\")), col = c(\"red\",\"black\"), lty = c(\"solid\",NA), pch=c(NA,\"o\"))\n      }\n    }\n    \n    \n    ############################################################################\n    #functionality pr.parplot start\n    if(x[[\"ind.par.est\"]][[\"numberOfParameters\"]]==2){\n      pr.parplot2(x);\n    }else if(x[[\"ind.par.est\"]][[\"numberOfParameters\"]]==3){\n      pr.parplot3(x);\n    }else{\n      stop(\"Printing of parameter only implemented for two and three parameters!\");\n    }\n  }\n  \n  \n  ########################################################################################\n  ########################################################################################\n  #functionality pr start:\n  \n  #check the input\n  allowedDistributions=c(\"norm\",\"logn\",\"gev\",\"gamma\");\n  checkInput(x,allowedDistributions);\n  \n  if(is.null(x[[\"sim\"]]))\n    x[[\"sim\"]]=FALSE\n  \n  if(is.null(x[[\"type\"]])){\n    x[[\"type\"]]=\"fit\";\n  }else{\n    if(x[[\"type\"]]!=\"diag\" && x[[\"type\"]] !=\"fit\"){\n      x[[\"type\"]]=\"fit\";\n    }\n  }\n  \n  #estimate parameters for each predictor level\n  ind.par.est = suppressWarnings2(estimateParameters(x),\"NaNs produced\");\n  \n  \n  #define variable for holding information\n  val = list();\n  val[[\"input\"]]=x;\n  val[[\"ind.par.est\"]]=ind.par.est;\n  \n  #plot and return in case of diagnosis plot\n  if(x[[\"type\"]]==\"diag\"){\n    pr.parplot(val)\n    return(val);\n  }\n  \n  #estimate structure parameter\n  struct.par.est = estimateStructureParameter(x,ind.par.est)\n  val[[\"struct.par.opt.result\"]]=struct.par.est;\n  val[[\"struct.par.est\"]]=struct.par.est$par;\n  \n\n  #calculate chi2 test p-value for goodness of fit\n  if(is.null(x[[\"quantiles\"]])){\n    no.observations=length(val[[\"input\"]][[\"xval\"]])\n    no.iqr.areas=round(no.observations/20)\n    val[[\"input\"]][[\"quantiles\"]]=1:(no.iqr.areas-1)/no.iqr.areas\n  }\n  chi2=chi2.test(val)\n  val[[\"chi2.test\"]]=chi2\n  \n  if(x[[\"sim\"]]!=TRUE)\n    pr.parplot(val)\n  \n  return(val);\n}\n\n\n\n\n########################################################################################\n########################################################################################\n#SIMULATION\n#input....input list like for pr()\n#ratio....p.u. (0<ratio<1) amount of observations per stress level used for fitting\n#times...number of times evaluation is done\npr.sim<-function(input, ratio, times, sim=NULL){\n  ############################################################################\n  #needed function for pr.sim\n  \n  \n  ##############\n  #chi2-test functions\n  \n  getChi2Value = function(quantiles,quantile.numbers){\n    no.stress=dim(quantile.numbers)[1]-1\n    no.quantile.areas=dim(quantile.numbers)[2]-1\n    no.observations=sum(quantile.numbers)-sum(quantile.numbers[1])\n    observed=c()\n    expected=c()\n    for(i in 1:no.quantile.areas){\n      observed=c(observed,sum(quantile.numbers[[i+1]]))\n      if(i==1){\n        expected=c(expected,quantiles[1])\n      }else if(i==no.quantile.areas){\n        expected=c(expected,1-quantiles[i-1])\n      }else{\n        expected=c(expected,quantiles[i]-quantiles[i-1])\n      }\n    }\n    expected=expected*no.observations\n    val=sum((observed-expected)^2/expected)\n    return(val)\n  }\n  \n  #x...xval to be tested\n  #y...yval to be tested\n  #quantiles....vector of qunatile area e.g.: c(0.25,0.5,0.75)\n  #qunatileValues....values of the corresponding quantile (per stresslevel)\n  getQuantileNumbers<-function(x,y,quantiles,quantileValues){\n    stress=unique(x);\n    A=matrix(rep(0,(length(stress)+1)*(length(quantiles)+1)),nrow=(length(stress)+1),ncol=(length(quantiles)+1));\n    for(i in 1:length(stress)){\n      data=part(y,x==stress[i])\n      for(j in 1:(length(quantiles)+1)){\n        if(j==1){\n          A[i,j]=sum(data<quantileValues[i,j+1])\n        }else if(j==(length(quantiles)+1)){\n          A[i,j]=sum(data >= quantileValues[i,j])\n        }else{\n          A[i,j]=sum(data<quantileValues[i,j+1] & data >= quantileValues[i,j])\n        }\n        \n      }\n    }\n    for(j in 1:(length(quantiles)+1)){\n      A[length(stress)+1,j]=sum(A[,j])\n    }\n    \n    df=data.frame(c(stress,0))\n    for(i in 1:(length(quantiles)+1)){\n      if(i==1){\n        df[[paste(\"q_0-q_\",as.character(quantiles[i]), sep= \"\")]]=A[,i];\n      }else if(i==(length(quantiles)+1)){\n        df[[paste(\"q_\",as.character(quantiles[i-1]),\"-q_1\", sep= \"\")]]=A[,i];\n      }else{\n        df[[paste(\"q_\",as.character(quantiles[i-1]),\"-q_\",as.character(quantiles[i]), sep= \"\")]]=A[,i];\n      }\n    }\n    return(df);\n    \n  }\n  \n  \n  #takes two vektors of the same size, returns those elements of vector\n  #one where vector two contains true\n  part<-function(data,bool)\n  {\n    if(length(bool)!=length(data))\n      stop(\"vectors need to be of the same size!\") \n    ret=c()\n    for(i in 1:length(bool))\n      if(bool[i])\n        ret[length(ret)+1]=data[i]\n    ret\n  } \n  \n  #creates random bool matrix\n  create.rand.boolmatrix<-function(input, ratio, times){\n    x=input[[\"xval\"]]\n    stress=unique(x)\n    no.lines=length(x)\n    ratio.new=round(ratio*length(x))\n    #warning(\"Random observation generation not implemented properly just yet\");\n    #return(t(replicate(length(input[[\"xval\"]]),rnorm(times))<=0.85))\n    max.times=1;\n    for(gr in 1:length(stress)){\n      gr.len=sum(stress[gr]==x)\n      gr.ratio=round((1-ratio)*gr.len) \n      max.times=max.times*choose(gr.len,gr.ratio)\n    }\n    if(max.times<times)\n      stop(paste(\"number of simulation too big for this datasample\"));\n    vectors=list()\n    old.percentage=0;\n    for(col in 1:times){\n      if(round(100*col/times) != old.percentage){\n        old.percentage=round(100*col/times)\n        msg=paste(\"creating simulation matrix - \",as.character(old.percentage),\"% done. Abort with ESC.\", sep=\"\")\n        status.update(msg);\n      }\n      #do-while loop\n      repeat{\n        bool.vec=c()\n        for(gr in 1:length(stress)){\n          gr.len=sum(stress[gr]==x)\n          gr.ratio=round((1-ratio)*gr.len) #number of FALSE\n          if(gr.ratio<=0 || gr.ratio>=gr.len)\n            stop(\"ratio too small or too large - need to be between 1 and 0 and be adjusted to the group size!\");\n          tmp.vec=rep(TRUE,gr.len)\n          pos.to.change=sample(1:gr.len,gr.ratio)\n          for(i in 1:length(pos.to.change)){\n            tmp.vec[pos.to.change]=FALSE\n          }\n          bool.vec=c(bool.vec,tmp.vec)\n        }\n        stop.rep=TRUE\n        if(length(vectors)!=0){\n          for(i in 1:length(vectors)){\n            if(sum(bool.vec==vectors[[i]])==length(bool.vec)){\n              stop.rep=FALSE\n            }\n          }\n        }\n        if(stop.rep){\n          break\n        }\n      }\n      vectors[[col]]=bool.vec\n    }\n    #warning(\"no check for multiple appereance of the same vector\");\n    mat=c()\n    for(i in 1:times){\n      mat=c(mat,vectors[[i]])\n    }\n    return(matrix(mat,nrow=no.lines,byrow=FALSE))\n    \n  }\n  \n  #one simulation step \n  #input ... input list like for pr()\n  #bool ... boolvector of size length(input[[\"xval\"]]) - specifies which values are takern for fitting (TRUE)\n  #         and which ones are taking for evaluation (FALSE)\n  simul<-function(bool,input){\n    x.fit=part(input[[\"xval\"]],bool)\n    y.fit=part(input[[\"yval\"]],bool)\n    x.eval=part(input[[\"xval\"]],bool==FALSE)\n    y.eval=part(input[[\"yval\"]],bool==FALSE)\n    input.new=input\n    input.new[[\"xval\"]]=x.fit\n    input.new[[\"yval\"]]=y.fit\n    result=pr(input.new)\n    #evaluation\n    quantile.numbers=getQuantileNumbers(x.eval,y.eval,input[[\"quantiles\"]],result$chi2.test[[\"quantile.values\"]]);\n    chi2.value=getChi2Value(input[[\"quantiles\"]],quantile.numbers)\n    df=length(x.eval)\n    #warning(\"Degrees of freedom for chi2 test not corrected yet!\");\n    p.value=pchisq(chi2.value,df);\n    return(p.value)\n  }\n\n  status.update<-function(string){\n    cat(\"                                                                           \", \" \\r\")\n    flush.console();\n    cat(paste(string,\"                                                \"), \" \\r\")\n    flush.console();\n  }\n  \n  #print gained EDF for p-values\n  print.edf<-function(x, points=FALSE){\n    x.new=unique(sort(x))\n    #points=FALSE\n    no.ob=length(x.new)\n    y.new=c()\n    for(j in 1:no.ob){\n      y.tmp=sum(x.new<=x.new[j])/no.ob\n      y.new=c(y.new,y.tmp)\n    }\n    plot(1, type=\"n\", xlab=\"\", ylab=\"\", xlim=c(0, 1), ylim=c(0, 1))\n    #abline(h=0,col=\"grey\")\n    #abline(v=0,col=\"grey\")\n    if(x.new[1]>0)\n      segments(0,0,x.new[1],0,col=\"red\")\n    if(x.new[no.ob]<1){\n      segments(x.new[no.ob],1,1,1,col=\"red\")\n    }else if(points){\n      points(1,1,col=\"red\",pch=20)\n    }\n    for(j in 1:(no.ob-1)){\n      segments(x.new[j],y.new[j],x.new[j+1],y.new[j],col=\"red\")\n    }\n    if(points)\n      points(x.new,y.new,col=\"red\",pch=20)\n    \n  }\n  \n  #supress only special warning\n  suppressWarnings2<-function(expr, regex=character()){\n    withCallingHandlers(expr, warning=function(w) {\n      if (length(regex) == 1 && length(grep(regex, conditionMessage(w)))) {\n        invokeRestart(\"muffleWarning\")\n      }\n    })\n  } \n  \n  \n  get.time<-function(sec){\n    if(sec<60){\n      return(paste(as.character(sec),\"[s]\",sep=\"\"))\n    }else{\n      n.min=sec%/%60\n      n.sec=as.character(sec-n.min*60)\n      if(nchar(n.sec)==1)\n        n.sec=paste(\"0\",n.sec,sep=\"\")\n      return(paste(as.character(n.min),\"[m] \",n.sec,\"[s]\",sep=\"\"))\n    }\n  }\n  \n  #performes simulation in case an observation is given\n  simulation.observation<-function(input,ratio,times){ \n    input[[\"type\"]]=\"fit\"\n    \n    if(is.null(input[[\"quantiles\"]]))\n      stop(\"Quantiles are needed for this approach!\")\n    input[[\"sim\"]]=TRUE\n    p.val=c()\n    display.steps=0.1\n    status.update(\"creating simulation matrix\");\n    bool.m=create.rand.boolmatrix(input, ratio, times)\n    status.update(\"start calculation\");\n    start.time = proc.time()[[\"elapsed\"]]\n    old.val=-1;\n    for(c in 1:times){\n      if(TRUE || (c/times)%%0.1==0){\n        val=round(100*(c/times))\n        if(old.val != val){\n          old.val=val;\n          time.string=get.time(round(proc.time()[[\"elapsed\"]]-start.time))\n          msg = paste(\"Calculated \",as.character(val),\"% in \",time.string ,\". Abort with ESC.\",sep=\"\");\n          status.update(msg);\n        }\n      }\n      bool=bool.m[,c]\n      try({\n        p.val.tmp = suppressWarnings2(simul(bool,input),\"NaNs produced\");\n        p.val=c(p.val,p.val.tmp)\n      }, silent=TRUE)\n    }\n    msg=paste(\"Simulation done in \",get.time(round(proc.time()[[\"elapsed\"]]-start.time)),\" with \",as.character(round(100*length(p.val)/times)),\"% success rate.\",sep=\"\");\n    status.update(msg);\n    par(mfrow=c(2,1))\n    print.edf(p.val)\n    hist(p.val,main=\"\")\n    par(mfrow=c(1,1))\n    return(p.val)\n  }\n  \n  \n  ###########################################################################\n  #pr.sim functionality start\n  if(is.null(sim)){\n    return(simulation.observation(input,ratio,times))\n  }else{\n    if(is.null(sim[[\"dist\"]]))\n      stop(\"A distribution (sim[[\\\"dist\\\"]]) has to be defined for generating a sample!\");\n    if(is.null(sim[[\"xval\"]]))\n      stop(\"Predictor-vector (sim[[\\\"xval\\\"]]) values for the sample must be defined!\");\n    if(is.null(sim[[\"n\"]]))\n      stop(\"A vector (sim[[\\\"n\\\"]]) must be defined specifying the number of observation at the predictor values!\");\n    return(NULL);\n  }\n\n}\n\n#load example dataset\nload.data<-function(){\n  data=matrix(rep(NA,600),nrow=200)\n  data[1,1]=294.3; data[1,2]=5300; data[1,3]=0; data[2,1]=294.3; data[2,2]=6200; \n  data[2,3]=0; data[3,1]=294.3; data[3,2]=6500; data[3,3]=0; data[4,1]=294.3; \n  data[4,2]=6600; data[4,3]=0; data[5,1]=294.3; data[5,2]=7000; data[5,3]=0; \n  data[6,1]=294.3; data[6,2]=7500; data[6,3]=0; data[7,1]=294.3; data[7,2]=8000; \n  data[7,3]=0; data[8,1]=294.3; data[8,2]=8400; data[8,3]=0; data[9,1]=294.3; \n  data[9,2]=8700; data[9,3]=0; data[10,1]=294.3; data[10,2]=8800; data[10,3]=0; \n  data[11,1]=294.3; data[11,2]=9000; data[11,3]=0; data[12,1]=294.3; data[12,2]=9200; \n  data[12,3]=0; data[13,1]=294.3; data[13,2]=9200; data[13,3]=0; data[14,1]=294.3; \n  data[14,2]=9400; data[14,3]=0; data[15,1]=294.3; data[15,2]=9500; data[15,3]=0; \n  data[16,1]=294.3; data[16,2]=9500; data[16,3]=0; data[17,1]=294.3; data[17,2]=9800; \n  data[17,3]=0; data[18,1]=294.3; data[18,2]=10000; data[18,3]=0; data[19,1]=294.3; \n  data[19,2]=10500; data[19,3]=0; data[20,1]=294.3; data[20,2]=11800; data[20,3]=0; \n  data[21,1]=220.7; data[21,2]=5100; data[21,3]=0; data[22,1]=220.7; data[22,2]=6100; \n  data[22,3]=0; data[23,1]=220.7; data[23,2]=7000; data[23,3]=0; data[24,1]=220.7; \n  data[24,2]=7700; data[24,3]=0; data[25,1]=220.7; data[25,2]=8600; data[25,3]=0; \n  data[26,1]=220.7; data[26,2]=9000; data[26,3]=0; data[27,1]=220.7; data[27,2]=9100; \n  data[27,3]=0; data[28,1]=220.7; data[28,2]=9300; data[28,3]=0; data[29,1]=220.7;\n  data[29,2]=9600; data[29,3]=0; data[30,1]=220.7; data[30,2]=9700; data[30,3]=0; \n  data[31,1]=220.7; data[31,2]=9700; data[31,3]=0; data[32,1]=220.7; data[32,2]=10100; \n  data[32,3]=0; data[33,1]=220.7; data[33,2]=10300; data[33,3]=0; data[34,1]=220.7; \n  data[34,2]=11200; data[34,3]=0; data[35,1]=220.7; data[35,2]=11500; data[35,3]=0; \n  data[36,1]=220.7; data[36,2]=11600; data[36,3]=0; data[37,1]=220.7; data[37,2]=12300; \n  data[37,3]=0; data[38,1]=220.7; data[38,2]=12500; data[38,3]=0; data[39,1]=220.7; \n  data[39,2]=13400; data[39,3]=0; data[40,1]=220.7; data[40,2]=15900; data[40,3]=0; \n  data[41,1]=176.6; data[41,2]=6200; data[41,3]=0; data[42,1]=176.6; data[42,2]=9400; \n  data[42,3]=0; data[43,1]=176.6; data[43,2]=10000; data[43,3]=0; data[44,1]=176.6; \n  data[44,2]=10000; data[44,3]=0; data[45,1]=176.6; data[45,2]=10200; data[45,3]=0; \n  data[46,1]=176.6; data[46,2]=10800; data[46,3]=0; data[47,1]=176.6; data[47,2]=11300; \n  data[47,3]=0; data[48,1]=176.6; data[48,2]=12600; data[48,3]=0; data[49,1]=176.6; \n  data[49,2]=12800; data[49,3]=0; data[50,1]=176.6; data[50,2]=13900; data[50,3]=0; \n  data[51,1]=176.6; data[51,2]=14000; data[51,3]=0; data[52,1]=176.6; data[52,2]=14200; \n  data[52,3]=0; data[53,1]=176.6; data[53,2]=14300; data[53,3]=0; data[54,1]=176.6; \n  data[54,2]=14700; data[54,3]=0; data[55,1]=176.6; data[55,2]=15100; data[55,3]=0; \n  data[56,1]=176.6; data[56,2]=15200; data[56,3]=0; data[57,1]=176.6; data[57,2]=16600; \n  data[57,3]=0; data[58,1]=176.6; data[58,2]=16900; data[58,3]=0; data[59,1]=176.6; \n  data[59,2]=17000; data[59,3]=0; data[60,1]=176.6; data[60,2]=18200; data[60,3]=0; \n  data[61,1]=134.9; data[61,2]=9100; data[61,3]=0; data[62,1]=134.9; data[62,2]=9300; \n  data[62,3]=0; data[63,1]=134.9; data[63,2]=9400; data[63,3]=0; data[64,1]=134.9; \n  data[64,2]=9700; data[64,3]=0; data[65,1]=134.9; data[65,2]=14500; data[65,3]=0; \n  data[66,1]=134.9; data[66,2]=15900; data[66,3]=0; data[67,1]=134.9; data[67,2]=16000; \n  data[67,3]=0; data[68,1]=134.9; data[68,2]=16200; data[68,3]=0; data[69,1]=134.9; \n  data[69,2]=17900; data[69,3]=0; data[70,1]=134.9; data[70,2]=18500; data[70,3]=0; \n  data[71,1]=134.9; data[71,2]=19800; data[71,3]=0; data[72,1]=134.9; data[72,2]=20800; \n  data[72,3]=0; data[73,1]=134.9; data[73,2]=21000; data[73,3]=0; data[74,1]=134.9; \n  data[74,2]=21800; data[74,3]=0; data[75,1]=134.9; data[75,2]=22100; data[75,3]=0; \n  data[76,1]=134.9; data[76,2]=22400; data[76,3]=0; data[77,1]=134.9; data[77,2]=22400; \n  data[77,3]=0; data[78,1]=134.9; data[78,2]=25700; data[78,3]=0; data[79,1]=134.9; \n  data[79,2]=25800; data[79,3]=0; data[80,1]=134.9; data[80,2]=27800; data[80,3]=0; \n  data[81,1]=105.4; data[81,2]=12800; data[81,3]=0; data[82,1]=105.4; data[82,2]=15600;\n  data[82,3]=0; data[83,1]=105.4; data[83,2]=17400; data[83,3]=0; data[84,1]=105.4; \n  data[84,2]=19000; data[84,3]=0; data[85,1]=105.4; data[85,2]=19000; data[85,3]=0; \n  data[86,1]=105.4; data[86,2]=19700; data[86,3]=0; data[87,1]=105.4; data[87,2]=20000; \n  data[87,3]=0; data[88,1]=105.4; data[88,2]=21000; data[88,3]=0; data[89,1]=105.4;\n  data[89,2]=21300; data[89,3]=0; data[90,1]=105.4; data[90,2]=24400; data[90,3]=0; \n  data[91,1]=105.4; data[91,2]=25100; data[91,3]=0; data[92,1]=105.4; data[92,2]=25400;\n  data[92,3]=0; data[93,1]=105.4; data[93,2]=26700; data[93,3]=0; data[94,1]=105.4; \n  data[94,2]=26800; data[94,3]=0; data[95,1]=105.4; data[95,2]=26900; data[95,3]=0; \n  data[96,1]=105.4; data[96,2]=28300; data[96,3]=0; data[97,1]=105.4; data[97,2]=28500; \n  data[97,3]=0; data[98,1]=105.4; data[98,2]=29500; data[98,3]=0; data[99,1]=105.4; \n  data[99,2]=30900; data[99,3]=0; data[100,1]=105.4; data[100,2]=38200; data[100,3]=0;\n  data[101,1]=83.4; data[101,2]=18200; data[101,3]=0; data[102,1]=83.4; data[102,2]=25000; \n  data[102,3]=0; data[103,1]=83.4; data[103,2]=25700; data[103,3]=0; data[104,1]=83.4;\n  data[104,2]=28600; data[104,3]=0; data[105,1]=83.4; data[105,2]=29000; data[105,3]=0; \n  data[106,1]=83.4; data[106,2]=33700; data[106,3]=0; data[107,1]=83.4; data[107,2]=35000; \n  data[107,3]=0; data[108,1]=83.4; data[108,2]=36400; data[108,3]=0; data[109,1]=83.4; \n  data[109,2]=39900; data[109,3]=0; data[110,1]=83.4; data[110,2]=40000; data[110,3]=0; \n  data[111,1]=83.4; data[111,2]=40700; data[111,3]=0; data[112,1]=83.4; data[112,2]=44000; \n  data[112,3]=0; data[113,1]=83.4; data[113,2]=45100; data[113,3]=0; data[114,1]=83.4; \n  data[114,2]=46000; data[114,3]=0; data[115,1]=83.4; data[115,2]=46100; data[115,3]=0; \n  data[116,1]=83.4; data[116,2]=46800; data[116,3]=0; data[117,1]=83.4; data[117,2]=48700; \n  data[117,3]=0; data[118,1]=83.4; data[118,2]=50000; data[118,3]=0; data[119,1]=83.4; \n  data[119,2]=54300; data[119,3]=0; data[120,1]=83.4; data[120,2]=55600; data[120,3]=0; \n  data[121,1]=73.6; data[121,2]=12000; data[121,3]=0; data[122,1]=73.6; data[122,2]=40000; \n  data[122,3]=0; data[123,1]=73.6; data[123,2]=45000; data[123,3]=0; data[124,1]=73.6; \n  data[124,2]=48000; data[124,3]=0; data[125,1]=73.6; data[125,2]=62000; data[125,3]=0; \n  data[126,1]=73.6; data[126,2]=65000; data[126,3]=0; data[127,1]=73.6; data[127,2]=65000;\n  data[127,3]=0; data[128,1]=73.6; data[128,2]=67000; data[128,3]=0; data[129,1]=73.6; \n  data[129,2]=70000; data[129,3]=0; data[130,1]=73.6; data[130,2]=80000; data[130,3]=0;\n  data[131,1]=73.6; data[131,2]=81000; data[131,3]=0; data[132,1]=73.6; data[132,2]=83000;\n  data[132,3]=0; data[133,1]=73.6; data[133,2]=88000; data[133,3]=0; data[134,1]=73.6; \n  data[134,2]=91000; data[134,3]=0; data[135,1]=73.6; data[135,2]=92000; data[135,3]=0; \n  data[136,1]=73.6; data[136,2]=94000; data[136,3]=0; data[137,1]=73.6; data[137,2]=95000; \n  data[137,3]=0; data[138,1]=73.6; data[138,2]=104000; data[138,3]=0; data[139,1]=73.6;\n  data[139,2]=108000; data[139,3]=0; data[140,1]=73.6; data[140,2]=112000; data[140,3]=0;\n  data[141,1]=56.4; data[141,2]=114000; data[141,3]=0; data[142,1]=56.4; data[142,2]=130000; \n  data[142,3]=0; data[143,1]=56.4; data[143,2]=157000; data[143,3]=0; data[144,1]=56.4;\n  data[144,2]=157000; data[144,3]=0; data[145,1]=56.4; data[145,2]=159000; data[145,3]=0;\n  data[146,1]=56.4; data[146,2]=170000; data[146,3]=0; data[147,1]=56.4; data[147,2]=180000;\n  data[147,3]=0; data[148,1]=56.4; data[148,2]=201000; data[148,3]=0; data[149,1]=56.4; \n  data[149,2]=205000; data[149,3]=0; data[150,1]=56.4; data[150,2]=210000; data[150,3]=0;\n  data[151,1]=56.4; data[151,2]=230000; data[151,3]=0; data[152,1]=56.4; data[152,2]=244000; \n  data[152,3]=0; data[153,1]=56.4; data[153,2]=250000; data[153,3]=0; data[154,1]=56.4; \n  data[154,2]=251000; data[154,3]=0; data[155,1]=56.4; data[155,2]=257000; data[155,3]=0; \n  data[156,1]=56.4; data[156,2]=266000; data[156,3]=0; data[157,1]=56.4; data[157,2]=273000; \n  data[157,3]=0; data[158,1]=56.4; data[158,2]=287000; data[158,3]=0; data[159,1]=56.4; \n  data[159,2]=296000; data[159,3]=0; data[160,1]=56.4; data[160,2]=309000; data[160,3]=0;\n  data[161,1]=54; data[161,2]=285000; data[161,3]=0; data[162,1]=54; data[162,2]=308000; \n  data[162,3]=0; data[163,1]=54; data[163,2]=336000; data[163,3]=0; data[164,1]=54; \n  data[164,2]=377000; data[164,3]=0; data[165,1]=54; data[165,2]=380000; data[165,3]=0; \n  data[166,1]=54; data[166,2]=396000; data[166,3]=0; data[167,1]=54; data[167,2]=427000; \n  data[167,3]=0; data[168,1]=54; data[168,2]=497000; data[168,3]=0; data[169,1]=54; \n  data[169,2]=510000; data[169,3]=0; data[170,1]=54; data[170,2]=551000; data[170,3]=0; \n  data[171,1]=54; data[171,2]=560000; data[171,3]=0; data[172,1]=54; data[172,2]=595000; \n  data[172,3]=0; data[173,1]=54; data[173,2]=617000; data[173,3]=0; data[174,1]=54; \n  data[174,2]=660000; data[174,3]=0; data[175,1]=54; data[175,2]=668000; data[175,3]=0;\n  data[176,1]=54; data[176,2]=685000; data[176,3]=0; data[177,1]=54; data[177,2]=714000;\n  data[177,3]=0; data[178,1]=54; data[178,2]=733000; data[178,3]=0; data[179,1]=54; \n  data[179,2]=849000; data[179,3]=0; data[180,1]=54; data[180,2]=895000; data[180,3]=0; \n  data[181,1]=51.5; data[181,2]=820000; data[181,3]=0; data[182,1]=51.5; data[182,2]=839000; \n  data[182,3]=0; data[183,1]=51.5; data[183,2]=938000; data[183,3]=0; data[184,1]=51.5; \n  data[184,2]=1024000; data[184,3]=0; data[185,1]=51.5; data[185,2]=1040000; data[185,3]=0; \n  data[186,1]=51.5; data[186,2]=1048000; data[186,3]=0; data[187,1]=51.5; data[187,2]=1100000;\n  data[187,3]=0; data[188,1]=51.5; data[188,2]=1103000; data[188,3]=0; data[189,1]=51.5; \n  data[189,2]=1136000; data[189,3]=0; data[190,1]=51.5; data[190,2]=1145000; data[190,3]=0;\n  data[191,1]=51.5; data[191,2]=1147000; data[191,3]=0; data[192,1]=51.5; data[192,2]=1150000; \n  data[192,3]=0; data[193,1]=51.5; data[193,2]=1151000; data[193,3]=0; data[194,1]=51.5; \n  data[194,2]=1163000; data[194,3]=0; data[195,1]=51.5; data[195,2]=1200000; data[195,3]=0;\n  data[196,1]=51.5; data[196,2]=1210000; data[196,3]=0; data[197,1]=51.5; data[197,2]=1319000; \n  data[197,3]=0; data[198,1]=51.5; data[198,2]=1320000; data[198,3]=0; data[199,1]=51.5;\n  data[199,2]=1321000; data[199,3]=0; data[200,1]=51.5; data[200,2]=1630000; data[200,3]=0;\n  return(data)\n}\n\n\n\n",
    "created" : 1448394822656.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "772128224",
    "id" : "CF6424B6",
    "lastKnownWriteTime" : 1448398544,
    "path" : "C:/Users/moja/Dropbox/12 sem/Masterarbeit/R/par.reg/R/ParameterRegression.R",
    "project_path" : "R/ParameterRegression.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}